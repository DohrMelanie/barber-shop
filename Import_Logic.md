# Data Import Exercise: The Legacy System Upgrade

## Scenario

We have acquired a competitor's customer list with questionable methods, but their database export is... catastrophic. It's technically XML, but it was generated by a buggy legacy script that didn't follow standards.

Your task is to write a `LegacyFileFixer` that reads this "broken" stream, repairs it into valid XML, and then parses it into our `Appointment` model.

## The Data Format Issues

The input file `BrokenData.xml` has the following "features":

1.  **Multiple Roots**: The file is a fragment stream, effectively multiple `<Appointment>` nodes one after another without a single root element.
2.  **Unescaped Characters**: The `&` character appears in attributes (e.g. `Client="Smith & Sons"`) without being escaped to `&amp;`.
3.  **Inconsistent Dates**:
    - Some dates are `YYYY-MM-DD` (Standard).
    - Some dates are `DD.MM.YYYY` (German format).
4.  **Pipe-Separated Services**: The services are not child elements but a single attribute or element `Services="CUT|SHAVE|COLOR"`.
5.  **Missing Fields**: Some records lack mandatory fields.

## Requirements

### 1. The Fixer Logic (`LegacyFileFixer.cs`)

You must implement `FixStreamAsync(Stream input)`. It should:

1.  Read the input stream line by line or character by character.
2.  Wrap the entire content in a `<Root>` element to make it valid XML.
3.  Detect and escape `&` characters that are inside attribute values.
4.  Return a _new_ valid XML string or Stream that can be parsed by standard `System.Xml` or `XDocument`.

### 2. The Parser Logic

After fixing the XML, you must parse it.

- **Dates**: You must handle both `YYYY-MM-DD` and `DD.MM.YYYY`.
- **Services**: You must split the pipe-separated string (e.g., "HAIRCUT|SHAVE") and map them to `AppointmentService` objects.
  - Map "HAIRCUT" -> `Service { Name = "Haircut", Price = 30.00 }`
  - Map "SHAVE" -> `Service { Name = "Shave", Price = 20.00 }`
  - Map "COLOR" -> `Service { Name = "Color", Price = 50.00 }`
  - Any other service -> `Service { Name = "Unknown", Price = 0.00 }`

### 3. Error Handling

Your code should NOT crash on bad data. Instead, it should skip the bad record and return an `ImportError`.

| Condition                | Error Code                           |
| :----------------------- | :----------------------------------- |
| Missing `CustomerName`   | `ImportError.MissingCompulsoryField` |
| Invalid/Unparseable Date | `ImportError.InvalidDate`            |
| Zero Services found      | `ImportError.NoServices`             |

## Output

Your method should return a `FixResult` (which you can define) containing:

- `List<Appointment> Successes`
- `List<(string RecordId, ImportError Error)> Failures`
